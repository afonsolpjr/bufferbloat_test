from mininet.topo import Topo
from mininet.node import CPULimitedHost
from mininet.link import TCLink
from mininet.net import Mininet
from mininet.log import lg, info
from mininet.util import dumpNodeConnections
from mininet.cli import CLI

import matplotlib.pyplot as plt

from subprocess import Popen, PIPE
from time import sleep, time
from multiprocessing import Process
from argparse import ArgumentParser

from monitor import monitor_qlen

import sys
import os
import math
import numpy as np
from argparse import ArgumentParser
import json

parser = ArgumentParser(description="Bufferbloat tests")
parser.add_argument('--num-bbr', '-nbbr',
                    help="Número de hosts executando TCP BBR",
                    type=int,
                    required=True)

parser.add_argument('--num-reno', '-nreno',
                    help="Número de hosts executando TCP Reno",
                    type=int,
                    required=True)

parser.add_argument('--test-duration', '-t',
                    help="Duração do teste",
                    type=float,
                    default=60)

args = parser.parse_args()

data_shared_dir = "/vagrant/bufferbloat/data"
os.makedirs(data_shared_dir, exist_ok=True)

# Instalar Iperf3 mais recente (não tem no repositorio ubuntu/debian)
# - Ver no final da pagina: https://iperf.fr/iperf-download.php
#  Dei build from source com ./configure && make && make install
# AI deu problema de biblioteca que resolvi com sudo apt-get install lib32z1

# Classe da topologia
class TopoComp(Topo):
    "Simple topology for tcp traffic competition experiment."

    def build(self, n=2):
        h1 = self.addHost("h1")
        h2 = self.addHost("h2")

        # Here I have created a switch.  If you change its name, its
        # interface names will change from s0-eth1 to newname-eth1.
        switch = self.addSwitch('s0')

        self.addLink(h1, switch, bw=1000)
        self.addLink(switch, h2, bw=1000)

class Analyzer():
    
    class IperfData():
        """ Represents connection data generated by iperf.

        ...

        Attributes
        ----------
        algorith_name : str
            congestion control algorithm name
        data : list[dict]
            rows of data (a dict). in a row, values are indexed by labels
        

        data labels: 
            Time Transfer Bandwidth Rtry Cwnd/RTT 
        """
        def __init__(self, filename):
            self.algorithm_name = filename.split(".")[0]
            self.data = self.parser(filename)

        # time [ID] Interval Transfer Bandwidth Write/Err Rtry Cwnd/RTT NetPwr
        def parser(self, filename):
            with open(f"{data_shared_dir}/{filename}", mode='r') as stream:
                dados = json.load(stream)

            start_timestamp = dados['start']['timestamp']['timesecs']

            data = []
            for intervalo in dados['intervals']:
                linha = {}  
                linha['Time'] = start_timestamp + intervalo['sum']['start']
                linha['Transfer'] = intervalo['sum']['bytes'] / 1e6 # MBytes
                linha['Bandwidth'] = intervalo['sum']['bits_per_second'] / 1e6
                linha['Rtry'] = intervalo['sum']['retransmits']
                linha['Cwnd'] = intervalo['streams'][0]['snd_cwnd'] / 1e3 # KB
                linha['RTT'] = intervalo['streams'][0]['rtt'] / 1000
                

                data.append(linha)

            return data
               
        # End of data class

    def __init__(self):
        self.iperfdata = []
        for i in range(1, args.num_bbr + 1):
            file = f"bbr{i}.json"
            self.iperfdata.append(Analyzer.IperfData(file))
        for i in range(1, args.num_reno + 1):
            file = f"reno{i}.json"
            self.iperfdata.append(Analyzer.IperfData(file))

    def plot_timeseries(self,label):
        xs = []
        for iperfdata in self.iperfdata:
            xs.append([row["Time"] for row in iperfdata.data])
        start_time = min(xs, key=lambda x: x[0])[0]
           
        start_time-=0.1 #INTERVALO DAS MEDIÇÕES DO IPERF. SE MUDAR, TEM QUE MUDAR AQUI TB!
        # Colocando os eixos um em relação ao outro, usando os timestamps
        for i in range(0,len(xs[0])):
            for x in xs:
                x[i]-=start_time
        ys = []
        for iperfdata in self.iperfdata:
            ys.append([row[label] for row in iperfdata.data])

        plt.figure(figsize=(12, 5))
        
        args_plot = []
        for x, y in zip(xs, ys):
            args_plot.extend([x, y])
        lines = plt.plot(*args_plot)

        for i, line in enumerate(lines):
            algoritmo = self.iperfdata[i].algorithm_name
            cores = ['b', 'g', 'r', 'c', 'm', 'y']
            plt.setp(line, color=f'{cores[i]}', label=f"{algoritmo}")

        plt.title(f"{label} on bbr vs reno",visible=True)

        if label == "Bandwidth":
            ylabel = "Bandwidth (Mb/sec)"
        elif label == "Cwnd":
            ylabel = "Cwnd (KB/sec)"
        elif label == "RTT":
            ylabel = "RTT (ms)"
        elif label == "Transfer":
            ylabel = "Transferred Data (MB)"
        else:
            ylabel = label

        plt.xlabel("Time elapsed (sec)")
        plt.ylabel(ylabel)
        plt.grid()
        plt.legend()
        out = f"plots/{label}_{args.num_bbr}bbrVS{args.num_reno}reno.png"
        print(f"Salvando grafico {out}")
        
        plt.savefig(out)  
        plt.close()
        pass

# Iniciando mininet

print("[ Iniciando uma rede simples ]")
net = Mininet(topo=TopoComp(),host=CPULimitedHost, link=TCLink)
net.start()
net.pingAll()
print('\n')

h1 = net.get('h1')
h2 = net.get('h2')
# print(type(h1))
# Abrindo servidores
porta_inicial = 5000
print(f"h1 ip {h1.IP()}\nh2 ip {h2.IP()}")
print("Abrindo servidores..",end='')

for i in range(args.num_bbr + args.num_reno):
    h2.popen(f"iperf3 -s --port {porta_inicial + i}")

bbr_processes = []
for i in range(args.num_bbr):
    processo = h1.popen(f"iperf3 -c {h2.IP()} --json -p {porta_inicial + i} -i 0.1 -t {args.test_duration} --linux-congestion bbr > {data_shared_dir}/bbr{i+1}.json", shell=True)
    bbr_processes.append(processo)

reno_processes = []
for i in range(args.num_reno):
    processo = h1.popen(f"iperf3 -c {h2.IP()} --json -p {args.num_bbr + porta_inicial + i} -i 0.1 -t {args.test_duration} --linux-congestion reno > {data_shared_dir}/reno{i+1}.json", shell=True)
    reno_processes.append(processo)
sleep(2)

print(".")
print(h2.cmd("netstat -tulpn"))

start_time=time()
print("[Testes em execução]")
while (True):
    now=time()
    elapsed = now-start_time
    if(elapsed>=args.test_duration):
        break
    else:
        print(f"\rTempo restante = {int(args.test_duration-elapsed)}seg", end='')
        sleep(1)
print("\n")

for process in bbr_processes:
    process.wait()
for process in reno_processes:
    process.wait()

net.stop()

# Popen("cat /tmp/bbr.json /tmp/reno.json",shell=True).wait()

Popen(f"sudo chmod 666 {data_shared_dir}/bbr*.json {data_shared_dir}/reno*.json",shell=True).wait()
print("[Formatando dados]")
#Popen(f"sed -i '/sec\|Cwnd/!d' {data_shared_dir}/reno*.json {data_shared_dir}/bbr*.json ", shell=True).wait()

# TODO: Parametrizar o analyzer para considerar todos os cenários
analise = Analyzer()

# print("[Plotando graficos]")

analise.plot_timeseries("Bandwidth")
analise.plot_timeseries("RTT")
analise.plot_timeseries("Rtry")

print("[Liberando recursos]")
Popen("sudo mn -c 2> /dev/null", shell=True).wait()

