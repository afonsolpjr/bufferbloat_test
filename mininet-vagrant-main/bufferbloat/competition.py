
import matplotlib.pyplot as plt
import matplotlib.animation as animation

from subprocess import Popen, PIPE
from time import sleep, time
from multiprocessing import Process
from argparse import ArgumentParser

from monitor import monitor_qlen

import sys
import os
import math
import numpy as np
from argparse import ArgumentParser
import json

parser = ArgumentParser(description="Bufferbloat tests")
parser.add_argument('--num-bbr', '-nbbr',
                    help="Número de hosts executando TCP BBR",
                    type=int,
                    required=True)

parser.add_argument('--num-reno', '-nreno',
                    help="Número de hosts executando TCP Reno",
                    type=int,
                    required=True)

parser.add_argument('--test-duration', '-t',
                    help="Duração do teste",
                    type=float,
                    default=60)

parser.add_argument('-bw',
                    help="largura da banda dos links, em Mbits",
                    type=float,
                    default=1000)

parser.add_argument('--task',
                    help="Tarefa a se fazer. valores possiveis: \"net\" para execucao da simulacao, \"gif\" para gerar o plot animado de fairness",
                    type=str,
                    default="net")

args = parser.parse_args()

if(args.task=="net"):
    data_shared_dir = "/vagrant/bufferbloat/data"
    os.makedirs(data_shared_dir, exist_ok=True)
    from mininet.topo import Topo
    from mininet.node import CPULimitedHost
    from mininet.link import TCLink
    from mininet.net import Mininet
    from mininet.log import lg, info
    from mininet.util import dumpNodeConnections
    from mininet.cli import CLI
    
    # Classe da topologia
    class TopoComp(Topo):
        "Simple topology for tcp traffic competition experiment."

        def build(self, n=2):
            h1 = self.addHost("h1")
            h2 = self.addHost("h2")

            # Here I have created a switch.  If you change its name, its
            # interface names will change from s0-eth1 to newname-eth1.
            switch = self.addSwitch('s0')

            self.addLink(h1, switch, bw=args.bw)
            self.addLink(switch, h2, bw=args.bw)





class Analyzer():
    
    class IperfData():
        """ Represents connection data generated by iperf.

        ...

        Attributes
        ----------
        algorith_name : str
            congestion control algorithm name
        data : list[dict]
            rows of data (a dict). in a row, values are indexed by labels
        

        data labels: 
            Time Transfer Bandwidth Rtry Cwnd/RTT 
        """
        def __init__(self, filename):
            self.algorithm_name = filename.split(".")[0]
            self.data = self.parser(filename)

        # time [ID] Interval Transfer Bandwidth Write/Err Rtry Cwnd/RTT NetPwr
        def parser(self, filename):
            with open(f"{data_shared_dir}/{filename}", mode='r') as stream:
                dados = json.load(stream)

            start_timestamp = dados['start']['timestamp']['timesecs']

            data = []
            for intervalo in dados['intervals']:
                linha = {}  
                linha['Time'] = start_timestamp + intervalo['sum']['end']
                linha['Transfer'] = intervalo['sum']['bytes'] / 1e6 # MBytes
                linha['Bandwidth'] = intervalo['sum']['bits_per_second'] / 1e6
                linha['Rtry'] = intervalo['sum']['retransmits']
                linha['Cwnd'] = intervalo['streams'][0]['snd_cwnd'] / 1e3 # KB
                linha['RTT'] = intervalo['streams'][0]['rtt'] / 1000
                

                data.append(linha)

            return data
               
        # End of data class

    def __init__(self):
        self.iperfdata = []
        for i in range(1, args.num_bbr + 1):
            file = f"bbr{i}.json"
            self.iperfdata.append(Analyzer.IperfData(file))
        for i in range(1, args.num_reno + 1):
            file = f"reno{i}.json"
            self.iperfdata.append(Analyzer.IperfData(file))

    def plot_timeseries(self,label):
        if not os.path.exists("plots"):
            os.makedirs("plots")
        xs = []
        for iperfdata in self.iperfdata:
            xs.append([row["Time"] for row in iperfdata.data])
        start_time = min(xs, key=lambda x: x[0])[0]
           
        start_time-=0.1 #INTERVALO DAS MEDIÇÕES DO IPERF. SE MUDAR, TEM QUE MUDAR AQUI TB!
        # Colocando os eixos um em relação ao outro, usando os timestamps
        for i in range(0,len(xs[0])):
            for x in xs:
                x[i]-=start_time
        ys = []
        for iperfdata in self.iperfdata:
            ys.append([row[label] for row in iperfdata.data])

        plt.figure(figsize=(12, 5))
        
        args_plot = []
        for x, y in zip(xs, ys):
            args_plot.extend([x, y])
        lines = plt.plot(*args_plot)

        for i, line in enumerate(lines):
            algoritmo = self.iperfdata[i].algorithm_name
            cores = ['b', 'g', 'r', 'c', 'm', 'y']
            plt.setp(line, color=f'{cores[i]}', label=f"{algoritmo}")

        plt.title(f"{label} on bbr vs reno",visible=True)

        if label == "Bandwidth":
            ylabel = "Bandwidth (Mb/sec)"
        elif label == "Cwnd":
            ylabel = "Cwnd (KB/sec)"
        elif label == "RTT":
            ylabel = "RTT (ms)"
        elif label == "Transfer":
            ylabel = "Transferred Data (MB)"
        else:
            ylabel = label

        plt.xlabel("Time elapsed (sec)")
        plt.ylabel(ylabel)
        plt.grid()
        plt.legend()
        out = f"plots/{label}_{args.num_bbr}bbrVS{args.num_reno}reno.png"
        print(f"Salvando grafico {out}")
        
        plt.savefig(out)  
        plt.close()
        pass

    def fairness_plot(self):
        if not os.path.exists("plots"):
            os.makedirs("plots")
        # plotar x+y = bw

        # 1 linha: eficiencie
        # 2 linha, justica
        plt.figure(figsize=(10,10))
        lines = plt.plot([0,args.bw],[args.bw,0],[0,args.bw/2],[0,args.bw/2])
        efficiency,justice = lines
        plt.setp([efficiency,justice], color='black')

        # eixo x: data[0]   eixo y: data[1]
        plt.xlabel(f"Bandwidth(Mb/sec) - TCP {self.iperfdata[0].algorithm_name[:-1]}")
        plt.ylabel(f"Bandwidth(Mb/sec) - TCP {self.iperfdata[1].algorithm_name[:-1]}")
        plt.savefig("plots/teste.png")
        plt.close()
        pass
    
    def fairness_animation(self):
        xs = [row["Bandwidth"] for row in self.iperfdata[0].data]  # Reno
        ys = [row["Bandwidth"] for row in self.iperfdata[1].data]  # BBR
        
        fig, ax = plt.subplots(figsize=(10, 10))
        
        # Linhas de referência
        ax.plot([0, args.bw], [args.bw, 0], 'r--', label=f'Eficiência (x+y={args.bw} Mbps)')
        ax.plot([0, args.bw/2], [0, args.bw/2], 'g--', label='Justiça (x=y)')
        ax.set_xlim(0, args.bw)
        ax.set_ylim(0, args.bw)
        ax.set_xlabel(f"TCP {self.iperfdata[0].algorithm_name} (Mbps)")
        ax.set_ylabel(f"TCP {self.iperfdata[1].algorithm_name} (Mbps)")
        
        
        # Scatter com trajetória
        scat = ax.scatter([], [], c='b', s=50, label='Instante atual')
        line, = ax.plot([], [], 'b-', alpha=0.5, lw=2, label='Trajetória')  # Linha da trajetória
        
        # Anotações
        frame_text = ax.annotate(
            f"Tempo: 0s/{args.test_duration}s",
            xy=(0.02, 0.95),
            xycoords='axes fraction',
            fontsize=12,
            bbox=dict(boxstyle="round", fc="w"))
        
        ax.grid(True)
        ax.legend()

        def update(frame):
            # Atualiza scatter e trajetória
            scat.set_offsets([[xs[frame], ys[frame]]])
            line.set_data(xs[:frame+1], ys[:frame+1])
            
            # Atualiza anotação com tempo real
            time_elapsed = self.iperfdata[0].data[frame]["Time"] - self.iperfdata[0].data[0]["Time"]
            frame_text.set_text(f"Tempo: {time_elapsed:.1f}s/{args.test_duration}s")
            
            return scat, line, frame_text
        
        ani = animation.FuncAnimation(
            fig, update, frames=len(xs), 
            interval=50,  # 20 FPS
            blit=True
        )
        print("[Criando animação]")
        ani.save("plots/fairness_animation.gif")
        plt.close()

# experimentos:
def start_net():
    # Iniciando mininet
    print("[ Iniciando uma rede simples ]")
    net = Mininet(topo=TopoComp(),host=CPULimitedHost, link=TCLink)
    net.start()
    net.pingAll()
    print('\n')
    return net

def analytics(data_dir):

    # Popen("cat /tmp/bbr.json /tmp/reno.json",shell=True).wait()

    Popen(f"sudo chmod 666 {data_dir}/bbr*.json {data_dir}/reno*.json",shell=True).wait()
    print("[Formatando dados]")
    #Popen(f"sed -i '/sec\|Cwnd/!d' {data_shared_dir}/reno*.json {data_shared_dir}/bbr*.json ", shell=True).wait()

    # TODO: Parametrizar o analyzer para considerar todos os cenários
    analise = Analyzer()

    # print("[Plotando graficos]")

    analise.plot_timeseries("Bandwidth")
    analise.plot_timeseries("RTT")
    analise.plot_timeseries("Rtry")

    # analise.fairness_animation()  # Impossivel rodar na VM, demora muito. 
    # acho que é pq falta uma biblioteca (ffmpeg)e o matplotlib usa outra de plano B(Pillow), que nao é mt eficiente

def experiment():
    net = start_net()
    h1 = net.get('h1')
    h2 = net.get('h2')
 
    # Abrindo servidores
    porta_inicial = 5000
    print("Abrindo servidores no host2..",end='')

    for i in range(args.num_bbr + args.num_reno):
        h2.popen(f"iperf3 -s --port {porta_inicial + i}")
    print(".")
    print(h2.cmd("netstat -tulpn"))

    # Fluxos
    print("[Iniciando fluxos]")
    bbr_processes = []
    for i in range(args.num_bbr):
        processo = h1.popen(f"iperf3 -c {h2.IP()} --json -p {porta_inicial + i} -i 0.1 -t {args.test_duration} --linux-congestion bbr > {data_shared_dir}/bbr{i+1}.json", shell=True)
        bbr_processes.append(processo)

    reno_processes = []
    for i in range(args.num_reno):
        processo = h1.popen(f"iperf3 -c {h2.IP()} --json -p {args.num_bbr + porta_inicial + i} -i 0.1 -t {args.test_duration} --linux-congestion reno > {data_shared_dir}/reno{i+1}.json", shell=True)
        reno_processes.append(processo)
    sleep(2)

    # Contador
    start_time=time()
    print("[Testes em execução]")
    while (True):
        now=time()
        elapsed = now-start_time
        if(elapsed>=args.test_duration):
            break
        else:
            print(f"\rTempo restante = {int(args.test_duration-elapsed)}seg", end='')
            sleep(1)
    print("\n")


    analytics(data_shared_dir)
    #Finalização
    print("[Liberando recursos]")
    for process in bbr_processes:
        process.wait()
    for process in reno_processes:
        process.wait()

    net.stop()

def create_gif():
    analise = Analyzer()
    analise.fairness_animation()



if(args.task=="net"):
    experiment()
else:
    data_shared_dir = "./data"
    create_gif()