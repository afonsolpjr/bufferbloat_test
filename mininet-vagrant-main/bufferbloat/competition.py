from mininet.topo import Topo
from mininet.node import CPULimitedHost
from mininet.link import TCLink
from mininet.net import Mininet
from mininet.log import lg, info
from mininet.util import dumpNodeConnections
from mininet.cli import CLI

from subprocess import Popen, PIPE
from time import sleep, time
from multiprocessing import Process
from argparse import ArgumentParser

from monitor import monitor_qlen

import sys
import os
import math
import numpy as np
from argparse import ArgumentParser

parser = ArgumentParser(description="Bufferbloat tests")
parser.add_argument('--num-bbr', '-nbbr',
                    help="Número de hosts executando TCP BBR",
                    type=int,
                    required=True)

parser.add_argument('--num-reno', '-nreno',
                    help="Número de hosts executando TCP Reno",
                    type=int,
                    required=True)

parser.add_argument('--test-duration', '-t',
                    help="Duração do teste",
                    type=float,
                    default=90)

args = parser.parse_args()

data_shared_dir = "/vagrant/bufferbloat/data"

# Instalar Iperf3 mais recente (não tem no repositorio ubuntu/debian)
# - Ver no final da pagina: https://iperf.fr/iperf-download.php
#  Dei build from source com ./configure && make && make install
# AI deu problema de biblioteca que resolvi com sudo apt-get install lib32z1

# Classe da topologia
class TopoComp(Topo):
    "Simple topology for tcp traffic competition experiment."

    def build(self, n=2):
        h1 = self.addHost("h1")
        h2 = self.addHost("h2")

        # Here I have created a switch.  If you change its name, its
        # interface names will change from s0-eth1 to newname-eth1.
        switch = self.addSwitch('s0')

        self.addLink(h1, switch, bw=1000)
        self.addLink(switch, h2, bw=1000)

class Analyzer():
    
    class IperfData():
        """ Represents connection data generated by iperf.

        ...

        Attributes
        ----------
        algorith_name : str
            congestion control algorithm name
        labels : list[str]
            labels of data
        data : list[dict]
            rows of data (a dict). in a row, values are indexed by labels
        """
        def __init__(self, filename):
            self.algorithm_name = filename.split(".")[0]
            self.labels = None
            labels = None
            self.data = self.parser(filename)

        # time [ID] Interval Transfer Bandwidth Write/Err Rtry Cwnd/RTT NetPwr
        def parser(self, filename):

            with open(f"{data_shared_dir}/{filename}", mode='r') as stream:
                lines = stream.readlines()

            # Pega as labels da primeira linha
            data = []
            self.labels = []

            for line in lines[1:]:
                #1752798646.766227555 [5] 0.2000-0.3000 sec  1.30 MBytes   109 Mbits/sec  11/0          0     1077K/21098 us  648.57
                values = line.split()

                row = {}
                # Time Transfer Bandwidth Rtry Cwnd/RTT 

                self.labels.append("Time")
                row.update({"Time":float(values[0])})
                    
            
                self.labels.append("Transfer")
                # value in Mbytes
                row.update({"Transfer":self.to_MB(float(values[4]),values[5])})
                
                self.labels.append("Bandwith")
                # values in Mbits
                row.update({"Bandwith":self.to_mb(float(values[6]),values[7])})
                
                self.labels.append("Rtry")
                row.update({"Rtry":int(values[9])})

                self.labels.append("Cwnd")
                
                cwnd = values[10].split("/")[0][:-1] # formato do cwnd é 2304K, por exemplo
                row.update({"Cwnd":float(cwnd)})
                            
                self.labels.append("RTT")
                rtt = values[10].split("/")[1]
                row.update({"RTT":float(rtt)})

                data.append(row)
            
            return data
 
        #As all data will be in Mbits
        def to_mb(self, value, unit):
            if unit == "Kbits/sec":
                return value / 1e3
            elif unit == "Mbits/sec":
                return value 
            elif unit == "Gbits/sec":
                return value * 1e3
            elif unit == "bits/sec":
                return value / 1e6
            return value
        
        def to_MB(self, value, unit):
            if unit == "Kbites":
                return value / 1e3
            elif unit == "Mbytes":
                return value 
            elif unit == "Gbytes":
                return value * 1e3
            elif unit == "Bytes":
                return value / 1e6
            return value
        
        # End of data class

    def __init__(self, file1, file2):
        self.iperfdata1 = Analyzer.IperfData(file1)
        self.iperfdata2 = Analyzer.IperfData(file2)
        
        # dados de cada conexao ficam no atributo 'data' das conexoes. 

    

# Iniciando mininet

print("[ Iniciando uma rede simples ]")
net = Mininet(topo=TopoComp(),host=CPULimitedHost, link=TCLink)
net.start()
net.pingAll()
print('\n')

h1 = net.get('h1')
h2 = net.get('h2')
# print(type(h1))
# Abrindo servidores
bbr_port=5001
reno_port=5002
print(f"h1 ip {h1.IP()}\nh2 ip {h2.IP()}")
print("Abrindo servidores..",end='')

bbr_processes = []
for i in range(args.num_bbr):
    processo = h1.popen(f"iperf -c {h2.IP()} -p {bbr_port} -i 0.1 -t {args.test_duration} --linux-congestion bbr | while read line; do echo \"$(date +%s.%N) $line\"; done > {data_shared_dir}/bbr{i+1}.txt", shell=True)
    bbr_processes.append(processo)

reno_processes = []
for i in range(args.num_reno):
    processo = h1.popen(f"iperf -c {h2.IP()} -p {reno_port} -i 0.1 -t {args.test_duration} --linux-congestion reno| while read line; do echo \"$(date +%s.%N) $line\"; done > {data_shared_dir}/reno{i+1}.txt", shell=True)
    reno_processes.append(processo)
sleep(2)

print(".")
print(h2.cmd("netstat -tulpn"))

start_time=time()
print("[Testes em execução]")
while (True):
    now=time()
    elapsed = now-start_time
    if(elapsed>=args.test_duration):
        break
    else:
        print(f"\rTempo restante = {int(args.test_duration-elapsed)}seg", end='')
        sleep(1)
print("\n")

for process in bbr_processes:
    process.wait()
for process in reno_processes:
    process.wait()

net.stop()

# Popen("cat /tmp/bbr.txt /tmp/reno.txt",shell=True).wait()

Popen(f"sudo chmod 666 {data_shared_dir}/bbr*.txt {data_shared_dir}/reno*.txt",shell=True).wait()
print("[Formatando dados]")
Popen(f"sed -i '/sec\|Cwnd/!d' {data_shared_dir}/reno*.txt {data_shared_dir}/bbr*.txt ", shell=True).wait()

Popen(f"sed -i -E 's/\\[ +/[/' {data_shared_dir}/reno*.txt {data_shared_dir}/bbr*.txt", shell=True ).wait()

# TODO: Parametrizar o analyzer para considerar todos os cenários
analise = Analyzer("bbr.txt","reno.txt")


print("[Liberando recursos]")
Popen("sudo mn -c 2> /dev/null", shell=True).wait()

