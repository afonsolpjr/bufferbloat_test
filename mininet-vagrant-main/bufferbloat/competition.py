from mininet.topo import Topo
from mininet.node import CPULimitedHost
from mininet.link import TCLink
from mininet.net import Mininet
from mininet.log import lg, info
from mininet.util import dumpNodeConnections
from mininet.cli import CLI

import matplotlib.pyplot as plt

from subprocess import Popen, PIPE
from time import sleep, time
from multiprocessing import Process
from argparse import ArgumentParser

from monitor import monitor_qlen

import sys
import os
import math
import numpy as np

# Instalar Iperf3 mais recente (não tem no repositorio ubuntu/debian)
# - Ver no final da pagina: https://iperf.fr/iperf-download.php
#  Dei build from source com ./configure && make && make install
# AI deu problema de biblioteca que resolvi com sudo apt-get install lib32z1

# Classe da topologia
class TopoComp(Topo):
    "Simple topology for tcp traffic competition experiment."

    def build(self, n=2):
        h1 = self.addHost( "h1" )
        h2 = self.addHost( "h2" )

        # Here I have created a switch.  If you change its name, its
        # interface names will change from s0-eth1 to newname-eth1.
        switch = self.addSwitch('s0')

        # self.addLink( node1, node2, bw=10, delay='5ms', max_queue_size=1000, loss=10, use_htb=True): 
        # adds a bidirectional link with bandwidth, delay and loss characteristics, with a maximum queue size of 1000 
        # packets using the Hierarchical Token Bucket rate limiter and netem delay/loss emulator. 
        # The parameter bw is expressed as a number in Mbit; delay is expressed as a string with units in place (e.g. '5ms', '100us', '1s'); 
        # loss is expressed as a percentage (between 0 and 100); and max_queue_size is expressed in packets.

        self.addLink( h1, switch, bw=1000)
        self.addLink( switch, h2, bw=1000)

class Analyzer():
    
    class IperfData():
        """ Represents connection data generated by iperf.

        ...

        Attributes
        ----------
        algorith_name : str
            congestion control algorithm name
        labels : list[str]
            labels of data
        data : list[dict]
            rows of data (a dict). in a row, values are indexed by labels
        

        data labels: 
            Time Transfer Bandwidth Rtry Cwnd/RTT 
        """
        def __init__(self, filename):
            self.algorithm_name = filename.split(".")[0]
            self.labels = None
            labels = None
            self.data = self.parser(filename)

        # time [ID] Interval Transfer Bandwidth Write/Err Rtry Cwnd/RTT NetPwr
        def parser(self, filename):

            with open(f"{data_shared_dir}/{filename}", mode='r') as stream:
                lines = stream.readlines()

            # Pega as labels da primeira linha
            data = []
            self.labels = []

            for line in lines[1:]:
                #1752798646.766227555 [5] 0.2000-0.3000 sec  1.30 MBytes   109 Mbits/sec  11/0          0     1077K/21098 us  648.57
                values = line.split()

                row = {}
               

                self.labels.append("Time")
                row.update({"Time":float(values[0])})
                    
            
                self.labels.append("Transfer")
                # value in Mbytes
                row.update({"Transfer":self.to_MB(float(values[4]),values[5])})
                
                self.labels.append("Bandwidth")
                # values in Mbits
                row.update({"Bandwidth":self.to_mb(float(values[6]),values[7])})
                
                self.labels.append("Rtry")
                row.update({"Rtry":int(values[9])})

                self.labels.append("Cwnd")
                
                cwnd = values[10].split("/")[0][:-1] # formato do cwnd é 2304K, por exemplo
                row.update({"Cwnd":float(cwnd)})
                            
                self.labels.append("RTT")
                rtt = values[10].split("/")[1]
                row.update({"RTT":float(rtt)/1000})

                data.append(row)
            
            return data
 
        #As all data will be in Mbits
        def to_mb(self, value, unit):
            if unit == "Kbits/sec":
                return value / 1e3
            elif unit == "Mbits/sec":
                return value 
            elif unit == "Gbits/sec":
                return value * 1e3
            elif unit == "bits/sec":
                return value / 1e6
            return value
        
        def to_MB(self, value, unit):
            if unit == "KBytes":
                return value / 1024
            elif unit == "MBytes":
                return value
            elif unit == "GBytes":
                return value * 1024
            elif unit == "Bytes":
                return value / (1024 * 1024)
            return value
        
        # End of data class

    def __init__(self, file1, file2):
        self.iperfdata1 = Analyzer.IperfData(file1)
        self.iperfdata2 = Analyzer.IperfData(file2)
        
        # for row in self.iperfdata1.data: print(row)
        # dados de cada conexao ficam no atributo 'data' das conexoes.

    def plot_timeseries(self,label):
        
        x1 = [ row["Time"] for row in self.iperfdata1.data]
        x2 = [ row["Time"] for row in self.iperfdata2.data]
        start_time = x1[0] if x1[0]<x2[0] else x2[0]
           

        start_time-=0.1 #INTERVALO DAS MEDIÇÕES DO IPERF. SE MUDAR, TEM QUE MUDAR AQUI TB!
        # Colocando os eixos um em relação ao outro, usando os timestamps
        for i in range(0,len(x1)):
            x1[i]-=start_time
            x2[i]-=start_time
    
        y1 = [ row[label] for row in self.iperfdata1.data]
        y2 = [ row[label] for row in self.iperfdata2.data]

        plt.figure(figsize=(12, 5))  
        lines = plt.plot(x1, y1, x2, y2)

        l1,l2 = lines
        plt.setp(l1,color='r',label=f"{self.iperfdata1.algorithm_name}")
        plt.setp(l2,color='b',label=f"{self.iperfdata2.algorithm_name}")
        plt.title(f"{label} on {self.iperfdata1.algorithm_name} vs {self.iperfdata2.algorithm_name}",visible=True)

        if label == "Bandwidth":
            ylabel = "Bandwidth (Mb/sec)"
        elif label == "Cwnd":
            ylabel = "Cwnd (KB/sec)"
        elif label == "RTT":
            ylabel = "RTT (ms)"
        elif label == "Transfer":
            ylabel = "Transferred Data (MB)"
        else:
            ylabel = label

        plt.xlabel("Time elapsed (sec)")
        plt.ylabel(ylabel)
        plt.grid()
        plt.legend()
        out = f"plots/{label}_{self.iperfdata1.algorithm_name}VS{self.iperfdata2.algorithm_name}.png"
        print(f"Salvando grafico {out}")
        
        plt.savefig(out)  
        plt.close()
        pass

    

# Iniciando mininet

print("[ Iniciando uma rede simples ]")
net = Mininet(topo=TopoComp(),host=CPULimitedHost, link=TCLink)
net.start()
net.pingAll()
print('\n')

h1 = net.get('h1')
h2 = net.get('h2')
# print(type(h1))
# Abrindo servidores
bbr_port=5001
reno_port=5002
print(f"h1 ip {h1.IP()}\nh2 ip {h2.IP()}")
print("Abrindo servidores..",end='')
serv_bbr = h2.popen(f"iperf -s --port {bbr_port}")
serv_reno = h2.popen(f"iperf -s --port {reno_port}")
sleep(2)
print(".")
print(h2.cmd("netstat -tulpn"))

test_duration = 30
data_shared_dir = "/vagrant/bufferbloat/data"

bbr_process= h1.popen(f"iperf -c {h2.IP()} -p {bbr_port} -i 0.1 -t {test_duration} --linux-congestion bbr | while read line; do echo \"$(date +%s.%N) $line\"; done > {data_shared_dir}/bbr.txt", shell=True)
reno_process= h1.popen(f"iperf -c {h2.IP()} -p {reno_port} -i 0.1 -t {test_duration} --linux-congestion reno| while read line; do echo \"$(date +%s.%N) $line\"; done > {data_shared_dir}/reno.txt", shell=True)

start_time=time()
print("[Testes em execução]")
while (True):
    now=time()
    elapsed = now-start_time
    if(elapsed>=test_duration):
        break
    else:
        print(f"\rTempo restante = {int(test_duration-elapsed)}seg", end='')
        sleep(1)
print("\n")
bbr_process.wait()
reno_process.wait()

net.stop()

# Popen("cat /tmp/bbr.txt /tmp/reno.txt",shell=True).wait()

Popen(f"sudo chmod 666 {data_shared_dir}/bbr.txt {data_shared_dir}/reno.txt",shell=True).wait()
print("[Formatando dados]")
Popen(f"sed -i '/sec\|Cwnd/!d' {data_shared_dir}/reno.txt {data_shared_dir}/bbr.txt ", shell=True).wait()

Popen(f"sed -i -E 's/\\[ +/[/' {data_shared_dir}/reno.txt {data_shared_dir}/bbr.txt", shell=True ).wait()

analise = Analyzer("bbr.txt","reno.txt")

# print("[Plotando graficos]")

# analise.plot_timeseries("Bandwidth")
# analise.plot_timeseries("RTT")
# analise.plot_timeseries("Rtry")

print("[Liberando recursos]")
Popen("sudo mn -c 2> /dev/null", shell=True).wait()

